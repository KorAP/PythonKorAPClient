<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>KorAPClient API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>KorAPClient</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__pdoc__ = {&#39;tests&#39;: False}

import warnings
from itertools import product

import pandas as pd
import rpy2.robjects as robjects
import rpy2.robjects.packages as packages
import rpy2.robjects.pandas2ri as pandas2ri
from packaging import version
from rpy2.robjects.methods import RS4

CURRENT_R_PACKAGE_VERSION = &#34;0.8.0&#34;

KorAPClient = packages.importr(&#39;RKorAPClient&#39;)
if version.parse(KorAPClient.__version__) &lt; version.parse(CURRENT_R_PACKAGE_VERSION):
    warnings.warn(&#34;R-package RKorAPClient version &#34; + KorAPClient.__version__ + &#34; is outdated, please update.&#34;,
                  DeprecationWarning)

korapclient_converter = robjects.conversion.Converter(&#39;base empty converter&#39;)


@korapclient_converter.py2rpy.register(list)
def _rpy2py_robject(listObject):
    return robjects.StrVector(listObject)


robjects.conversion.set_conversion(robjects.default_converter + pandas2ri.converter + korapclient_converter)


def expand_grid(dictionary):
    &#34;&#34;&#34;Create a oandas DataFrame from all combinations of inputs

    - **dictionary** - dict with variable names as  keys and their values as vectors

    Returns:
        DataFrame with column names as specified by the dictionary key and all combinations of the specified values
        in the rows.

    Example:
        ```
        $ df = expand_grid({&#34;Year&#34;: range(2010, 2019), &#34;Country&#34;: [&#34;DE&#34;, &#34;CH&#34;] })

        $ df[&#34;vc&#34;] = &#34;textType=/Zeit.*/ &amp; pubPlaceKey = &#34; + df.Country + &#34; &amp; pubDate in &#34; + list(map(str, df.Year))
        ```
    &#34;&#34;&#34;

    return pd.DataFrame([row for row in product(*dictionary.values())],
                        columns=dictionary.keys())


# noinspection PyPep8Naming
class KorAPConnection(RS4):
    &#34;&#34;&#34;Connection to a KorAP server.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        &#34;&#34;&#34;Constructor keyword arguments:

        - **KorAPUrl** (default = `&#34;https://korap.ids-mannheim.de/&#34;`)
        - **apiVersion** (default = &#39;v1.0&#39;)
        - **apiUrl**
        - **accessToken** (default = `getAccessToken(KorAPUrl)`
        - **userAgent** (default = `&#34;Python-KorAP-Client&#34;`)
        - **timeout** (default = 110)
        - **verbose** (default = False)
        - **cache** (default = True)
        &#34;&#34;&#34;
        if &#39;userAgent&#39; not in kwargs:
            kwargs[&#34;userAgent&#34;] = &#34;Python-KorAP-Client&#34;
        kco = KorAPClient.KorAPConnection(*args, **kwargs)
        super().__init__(kco)

    def corpusStats(self, *args, **kwargs):
        &#34;&#34;&#34;Query the size of the whole corpus or a virtual corpus specified by the vc argument.

        - **vc** (default = &#34;&#34;)
        - **verbose** (default = kco@verbose)
        - **as.df** (default = True)

        Returns:
            `DataFrame`|`RS4`

        Example:
            ```
            $ df = kcon.corpusStats(&#34;pubDate in 2018 &amp; textType=/Zeit.*/ &amp; pubPlaceKey=IT&#34;, **{&#34;as.df&#34;: True})
            $ df[&#34;tokens&#34;]
            12150897
            ```
        &#34;&#34;&#34;
        default_kwargs = {&#34;as.df&#34;: True}
        default_kwargs.update(kwargs)
        return KorAPClient.corpusStats(self, *args, **default_kwargs)

    def frequencyQuery(self, *args, **kwargs):
        &#34;&#34;&#34;Query relative frequency of search term(s).

        - **query** - query string or list of query strings
        - **vc** - virtual corpus definition or list thereof  (default: &#34;&#34;)
        - **conf.level** - confidence level of the returned confidence interval (default = 0.95)
        - **as.alternatives** - decides whether queries should be treated as mutually exclusive and exhaustive wrt. to some meaningful class (e.g. spelling variants of a certain word form) (default = False)
        - **KorAPUrl** - instead of specifying the `query` and `vc` string parameters, you can copy your KorAP query URL here from the browser
        - **metadataOnly** - determines whether queries should return only metadata without any snippets. This can also be useful to prevent access rewrites. (default = True)
        - **ql** - query language: `&#34;poliqarp&#34; | &#34;cosmas2&#34; | &#34;annis&#34; | &#34;cql&#34; | &#34;fcsql&#34;` (default = `&#34;poliqarp&#34;`)
        - **accessRewriteFatal** - abort if query or given vc had to be rewritten due to insufficient rights (not yet implemented) (default = `True`)
        - **verbose** - (default = `self.verbose`)
        - **expand** - bool that decides if `query` and `vc` parameters are expanded to all of their combinations (default = `len(vc) != len(query)`)

        Returns:
            DataFrame with columns `&#39;query&#39;, &#39;totalResults&#39;, &#39;vc&#39;, &#39;webUIRequestUrl&#39;, &#39;total&#39;, &#39;f&#39;,
           &#39;conf.low&#39;, &#39;conf.high&#39;`.

        Example:
            ```
            $ kcon = KorAPConnection(verbose=True)
            $ kcon.frequencyQuery(&#34;Ameisenplage&#34;, vc=[&#34;pubDate in &#34;+str(y) for y in range(2010,2015)])
                                  query  totalResults  ...      conf.low     conf.high
            1  Ameisenplage             3  ...  9.727696e-10  1.200289e-08
            2  Ameisenplage            12  ...  3.838218e-09  1.275717e-08
            3  Ameisenplage             5  ...  2.013352e-09  1.356500e-08
            4  Ameisenplage             6  ...  2.691331e-09  1.519888e-08
            5  Ameisenplage             3  ...  8.629463e-10  1.064780e-08
            ```
        &#34;&#34;&#34;
        return KorAPClient.frequencyQuery(self, *args, **kwargs)

    def collocationScoreQuery(self, node, collocate, vc=&#34;&#34;, **kwargs):
        &#34;&#34;&#34;Get collocation scores for given node(s) and collocate(s).

        - **node** - target word
        - **collocate** - collocate of target word
        - **vc** - virtual corpus definition or list thereof  (default: &#34;&#34;)
        - **lemmatizeNodeQuery** - logical, set to TRUE if node query should be lemmatized, i.e. x -&gt; [tt/l=x]
        - **lemmatizeCollocateQuery** - logical, set to TRUE if collocate query should be lemmatized, i.e. x -&gt; [tt/l=x]
        - **leftContextSize** - size of the left context window
        - **rightContextSize** - size of the right context window
        - **scoreFunctions** - named list of R (!) score functions of the form function(O1, O2, O, N, E, window_size), see e.g. KorAPClient.pmi
        - **smoothingConstant** - smoothing constant will be added to all observed values

        Returns:
            DataFrame with columns `&#39;node&#39;, &#39;collocate&#39;, &#39;label&#39;, &#39;vc&#39;,&#39;webUIRequestUrl&#39;, &#39;w&#39;,  &#39;leftContextSize&#39;,
               &#39;rightContextSize&#39;, &#39;N&#39;, &#39;O&#39;, &#39;O1&#39;, &#39;O2&#39;, &#39;E&#39;, &#39;pmi&#39;, &#39;mi2&#39;, &#39;mi3&#39;, &#39;logDice&#39;, &#39;ll&#39;`

        Example:
            ```
            $ kcon = KorAPConnection(verbose=True)
            $ df = kcon.collocationScoreQuery(&#34;Grund&#34;, &#34;triftiger&#34;)
            ```
        &#34;&#34;&#34;
        return KorAPClient.collocationScoreQuery(self, node, collocate, vc, **kwargs)

    def collocationAnalysis(self, node, vc=&#34;&#34;, **kwargs):
        &#34;&#34;&#34; **EXPERIMENTAL**: Performs a collocation analysis for the given node (or query) in the given virtual corpus.

        - **node** - target word or list of target words
        - **vc** - string or list of strings describing the virtual corpus in which the query should be performed. An empty string (default) means the whole corpus, as far as it is license-wise accessible.
        - **lemmatizeNodeQuery** - if True, node query will be lemmatized, i.e. x -&gt; [tt/l=x]
        - **minOccur** - minimum absolute number of observed co-occurrences to consider a collocate candidate
        - **leftContextSize** - size of the left context window
        - **rightContextSize** - size of the right context window
        - **topCollocatesLimit** - limit analysis to the n most frequent collocates in the search hits sample
        - **searchHitsSampleLimit** - limit the size of the search hits sample
        - **ignoreCollocateCase** - bool, set to True if collocate case should be ignored
        - **withinSpan** - KorAP span specification for collocations to be searched within
        - **exactFrequencies** - if False, extrapolate observed co-occurrence frequencies from frequencies in search hits sample, otherwise retrieve exact co-occurrence frequencies
        - **stopwords** - vector of stopwords not to be considered as collocates
        - **seed** - seed for random page collecting order
        - **expand** - if True, node and vc parameters are expanded to all of their combinations

        Returns:
            DataFrame with columns `&#39;node&#39;, &#39;collocate&#39;, &#39;label&#39;, &#39;vc&#39;,&#39;webUIRequestUrl&#39;, &#39;w&#39;,  &#39;leftContextSize&#39;,
               &#39;rightContextSize&#39;, &#39;N&#39;, &#39;O&#39;, &#39;O1&#39;, &#39;O2&#39;, &#39;E&#39;, &#39;pmi&#39;, &#39;mi2&#39;, &#39;mi3&#39;, &#39;logDice&#39;, &#39;ll&#39;`

        Details:
            The collocation analysis is currently implemented on the client side, as some of the functionality is not yet provided by the KorAP backend. Mainly for this reason it is very slow (several minutes, up to hours), but on the other hand very flexible. You can, for example, perform the analysis in arbitrary virtual corpora, use complex node queries, and look for expression-internal collocates using the focus function (see examples and demo).
            To increase speed at the cost of accuracy and possible false negatives, you can decrease searchHitsSampleLimit and/or topCollocatesLimit and/or set exactFrequencies to FALSE.
            Note that currently not the tokenization provided by the backend, i.e. the corpus itself, is used, but a tinkered one. This can also lead to false negatives and to frequencies that differ from corresponding ones acquired via the web user interface.

        Example:
            ```
            $ kcon = KorAPConnection(verbose=True)
            $ df = kcon.collocationAnalysis(&#34;Grund&#34;)
            ```
        &#34;&#34;&#34;
        return KorAPClient.collocationAnalysis(self, node, vc, **kwargs)

    def corpusQuery(self, *args, **kwargs):
        &#34;&#34;&#34;Query search term(s).

        - **query** - query string or list of query strings
        - **vc** - virtual corpus definition or list thereof (default: &#34;&#34;)
        - **KorAPUrl** - instead of specifying the `query` and `vc` string parameters, you can copy your KorAP query URL here from the browser
        - **metadataOnly** - determines whether queries should return only metadata without any snippets. This can also be useful to prevent access rewrites. (default = True)
        - **ql** - query language: `&#34;poliqarp&#34; | &#34;cosmas2&#34; | &#34;annis&#34; | &#34;cql&#34; | &#34;fcsql&#34;` (default = `&#34;poliqarp&#34;`)
        - **fields** - (meta)data fields that will be fetched for every match (default = `[&#34;corpusSigle&#34;, &#34;textSigle&#34;, &#34;pubDate&#34;,  &#34;pubPlace&#34;, &#34;availability&#34;, &#34;textClass&#34;]`)
        - **verbose** - (default = `self.verbose`)

        Returns:
            `KorAPQuery`

        Example:
            ```
            $ kcon = KorAPConnection(verbose=True)
            $ q = kcon.corpusQuery(&#34;Ameisenplage&#34;)
            $ q = q.fetchAll()
            $ q.slots[&#39;collectedMatches&#39;]
                corpusSigle  ...                                          textClass
            1         WPD17  ...                                                NaN
            2         WPD17  ...                                                NaN
            3         WPD17  ...                                                NaN
            4         WPD17  ...                                                NaN
            5         WPD17  ...                                                NaN
            ..          ...  ...                                                ...
            126         Z83  ...                       freizeit-unterhaltung reisen
            127       MZE03  ...  freizeit-unterhaltung reisen natur-umwelt wett...
            128       MZE03  ...  freizeit-unterhaltung reisen staat-gesellschaf...
            129       MZE14  ...  wissenschaft populaerwissenschaft freizeit-unt...
            130       MZE00  ...                  wissenschaft populaerwissenschaft
            [130 rows x 6 columns]
            ```
        &#34;&#34;&#34;
        return KorAPQuery(self, *args, **kwargs)


class KorAPQuery(RS4):
    &#34;&#34;&#34;Query to a KorAP server.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        kco = KorAPClient.corpusQuery(*args, **kwargs)
        super().__init__(kco)

    def fetchNext(self, *args, **kwargs):
        &#34;&#34;&#34;Fetch next couple of query results

        - **offset** - start offset for query results to fetch
        - **maxFetch** - maximum number of query results to fetch
        - **verbose**
        - **randomizePageOrder** - fetch result pages in pseudo random order if true. (default = `False`)

        Returns:
            `KorAPQuery`
        &#34;&#34;&#34;
        return KorAPClient.fetchNext(self, *args, **kwargs)

    def fetchRest(self, *args, **kwargs):
        &#34;&#34;&#34;Fetch remaining query results

        - **verbose**

        Returns:
            `KorAPQuery`
        &#34;&#34;&#34;
        return KorAPClient.fetchRest(self, *args, **kwargs)

    def fetchAll(self, *args, **kwargs):
        &#34;&#34;&#34;Fetch all query results

        - **verbose**

        Returns:
            `KorAPQuery`

        Example:
            See `KorAPConnection.corpusQuery`.
        &#34;&#34;&#34;
        return KorAPClient.fetchAll(self, *args, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="KorAPClient.expand_grid"><code class="name flex">
<span>def <span class="ident">expand_grid</span></span>(<span>dictionary)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a oandas DataFrame from all combinations of inputs</p>
<ul>
<li><strong>dictionary</strong> - dict with variable names as
keys and their values as vectors</li>
</ul>
<h2 id="returns">Returns</h2>
<p>DataFrame with column names as specified by the dictionary key and all combinations of the specified values
in the rows.</p>
<h2 id="example">Example</h2>
<pre><code>$ df = expand_grid({&quot;Year&quot;: range(2010, 2019), &quot;Country&quot;: [&quot;DE&quot;, &quot;CH&quot;] })

$ df[&quot;vc&quot;] = &quot;textType=/Zeit.*/ &amp; pubPlaceKey = &quot; + df.Country + &quot; &amp; pubDate in &quot; + list(map(str, df.Year))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_grid(dictionary):
    &#34;&#34;&#34;Create a oandas DataFrame from all combinations of inputs

    - **dictionary** - dict with variable names as  keys and their values as vectors

    Returns:
        DataFrame with column names as specified by the dictionary key and all combinations of the specified values
        in the rows.

    Example:
        ```
        $ df = expand_grid({&#34;Year&#34;: range(2010, 2019), &#34;Country&#34;: [&#34;DE&#34;, &#34;CH&#34;] })

        $ df[&#34;vc&#34;] = &#34;textType=/Zeit.*/ &amp; pubPlaceKey = &#34; + df.Country + &#34; &amp; pubDate in &#34; + list(map(str, df.Year))
        ```
    &#34;&#34;&#34;

    return pd.DataFrame([row for row in product(*dictionary.values())],
                        columns=dictionary.keys())</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="KorAPClient.KorAPConnection"><code class="flex name class">
<span>class <span class="ident">KorAPConnection</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Connection to a KorAP server.</p>
<p>Constructor keyword arguments:</p>
<ul>
<li><strong>KorAPUrl</strong> (default = <code>"https://korap.ids-mannheim.de/"</code>)</li>
<li><strong>apiVersion</strong> (default = 'v1.0')</li>
<li><strong>apiUrl</strong></li>
<li><strong>accessToken</strong> (default = <code>getAccessToken(KorAPUrl)</code></li>
<li><strong>userAgent</strong> (default = <code>"Python-KorAP-Client"</code>)</li>
<li><strong>timeout</strong> (default = 110)</li>
<li><strong>verbose</strong> (default = False)</li>
<li><strong>cache</strong> (default = True)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KorAPConnection(RS4):
    &#34;&#34;&#34;Connection to a KorAP server.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        &#34;&#34;&#34;Constructor keyword arguments:

        - **KorAPUrl** (default = `&#34;https://korap.ids-mannheim.de/&#34;`)
        - **apiVersion** (default = &#39;v1.0&#39;)
        - **apiUrl**
        - **accessToken** (default = `getAccessToken(KorAPUrl)`
        - **userAgent** (default = `&#34;Python-KorAP-Client&#34;`)
        - **timeout** (default = 110)
        - **verbose** (default = False)
        - **cache** (default = True)
        &#34;&#34;&#34;
        if &#39;userAgent&#39; not in kwargs:
            kwargs[&#34;userAgent&#34;] = &#34;Python-KorAP-Client&#34;
        kco = KorAPClient.KorAPConnection(*args, **kwargs)
        super().__init__(kco)

    def corpusStats(self, *args, **kwargs):
        &#34;&#34;&#34;Query the size of the whole corpus or a virtual corpus specified by the vc argument.

        - **vc** (default = &#34;&#34;)
        - **verbose** (default = kco@verbose)
        - **as.df** (default = True)

        Returns:
            `DataFrame`|`RS4`

        Example:
            ```
            $ df = kcon.corpusStats(&#34;pubDate in 2018 &amp; textType=/Zeit.*/ &amp; pubPlaceKey=IT&#34;, **{&#34;as.df&#34;: True})
            $ df[&#34;tokens&#34;]
            12150897
            ```
        &#34;&#34;&#34;
        default_kwargs = {&#34;as.df&#34;: True}
        default_kwargs.update(kwargs)
        return KorAPClient.corpusStats(self, *args, **default_kwargs)

    def frequencyQuery(self, *args, **kwargs):
        &#34;&#34;&#34;Query relative frequency of search term(s).

        - **query** - query string or list of query strings
        - **vc** - virtual corpus definition or list thereof  (default: &#34;&#34;)
        - **conf.level** - confidence level of the returned confidence interval (default = 0.95)
        - **as.alternatives** - decides whether queries should be treated as mutually exclusive and exhaustive wrt. to some meaningful class (e.g. spelling variants of a certain word form) (default = False)
        - **KorAPUrl** - instead of specifying the `query` and `vc` string parameters, you can copy your KorAP query URL here from the browser
        - **metadataOnly** - determines whether queries should return only metadata without any snippets. This can also be useful to prevent access rewrites. (default = True)
        - **ql** - query language: `&#34;poliqarp&#34; | &#34;cosmas2&#34; | &#34;annis&#34; | &#34;cql&#34; | &#34;fcsql&#34;` (default = `&#34;poliqarp&#34;`)
        - **accessRewriteFatal** - abort if query or given vc had to be rewritten due to insufficient rights (not yet implemented) (default = `True`)
        - **verbose** - (default = `self.verbose`)
        - **expand** - bool that decides if `query` and `vc` parameters are expanded to all of their combinations (default = `len(vc) != len(query)`)

        Returns:
            DataFrame with columns `&#39;query&#39;, &#39;totalResults&#39;, &#39;vc&#39;, &#39;webUIRequestUrl&#39;, &#39;total&#39;, &#39;f&#39;,
           &#39;conf.low&#39;, &#39;conf.high&#39;`.

        Example:
            ```
            $ kcon = KorAPConnection(verbose=True)
            $ kcon.frequencyQuery(&#34;Ameisenplage&#34;, vc=[&#34;pubDate in &#34;+str(y) for y in range(2010,2015)])
                                  query  totalResults  ...      conf.low     conf.high
            1  Ameisenplage             3  ...  9.727696e-10  1.200289e-08
            2  Ameisenplage            12  ...  3.838218e-09  1.275717e-08
            3  Ameisenplage             5  ...  2.013352e-09  1.356500e-08
            4  Ameisenplage             6  ...  2.691331e-09  1.519888e-08
            5  Ameisenplage             3  ...  8.629463e-10  1.064780e-08
            ```
        &#34;&#34;&#34;
        return KorAPClient.frequencyQuery(self, *args, **kwargs)

    def collocationScoreQuery(self, node, collocate, vc=&#34;&#34;, **kwargs):
        &#34;&#34;&#34;Get collocation scores for given node(s) and collocate(s).

        - **node** - target word
        - **collocate** - collocate of target word
        - **vc** - virtual corpus definition or list thereof  (default: &#34;&#34;)
        - **lemmatizeNodeQuery** - logical, set to TRUE if node query should be lemmatized, i.e. x -&gt; [tt/l=x]
        - **lemmatizeCollocateQuery** - logical, set to TRUE if collocate query should be lemmatized, i.e. x -&gt; [tt/l=x]
        - **leftContextSize** - size of the left context window
        - **rightContextSize** - size of the right context window
        - **scoreFunctions** - named list of R (!) score functions of the form function(O1, O2, O, N, E, window_size), see e.g. KorAPClient.pmi
        - **smoothingConstant** - smoothing constant will be added to all observed values

        Returns:
            DataFrame with columns `&#39;node&#39;, &#39;collocate&#39;, &#39;label&#39;, &#39;vc&#39;,&#39;webUIRequestUrl&#39;, &#39;w&#39;,  &#39;leftContextSize&#39;,
               &#39;rightContextSize&#39;, &#39;N&#39;, &#39;O&#39;, &#39;O1&#39;, &#39;O2&#39;, &#39;E&#39;, &#39;pmi&#39;, &#39;mi2&#39;, &#39;mi3&#39;, &#39;logDice&#39;, &#39;ll&#39;`

        Example:
            ```
            $ kcon = KorAPConnection(verbose=True)
            $ df = kcon.collocationScoreQuery(&#34;Grund&#34;, &#34;triftiger&#34;)
            ```
        &#34;&#34;&#34;
        return KorAPClient.collocationScoreQuery(self, node, collocate, vc, **kwargs)

    def collocationAnalysis(self, node, vc=&#34;&#34;, **kwargs):
        &#34;&#34;&#34; **EXPERIMENTAL**: Performs a collocation analysis for the given node (or query) in the given virtual corpus.

        - **node** - target word or list of target words
        - **vc** - string or list of strings describing the virtual corpus in which the query should be performed. An empty string (default) means the whole corpus, as far as it is license-wise accessible.
        - **lemmatizeNodeQuery** - if True, node query will be lemmatized, i.e. x -&gt; [tt/l=x]
        - **minOccur** - minimum absolute number of observed co-occurrences to consider a collocate candidate
        - **leftContextSize** - size of the left context window
        - **rightContextSize** - size of the right context window
        - **topCollocatesLimit** - limit analysis to the n most frequent collocates in the search hits sample
        - **searchHitsSampleLimit** - limit the size of the search hits sample
        - **ignoreCollocateCase** - bool, set to True if collocate case should be ignored
        - **withinSpan** - KorAP span specification for collocations to be searched within
        - **exactFrequencies** - if False, extrapolate observed co-occurrence frequencies from frequencies in search hits sample, otherwise retrieve exact co-occurrence frequencies
        - **stopwords** - vector of stopwords not to be considered as collocates
        - **seed** - seed for random page collecting order
        - **expand** - if True, node and vc parameters are expanded to all of their combinations

        Returns:
            DataFrame with columns `&#39;node&#39;, &#39;collocate&#39;, &#39;label&#39;, &#39;vc&#39;,&#39;webUIRequestUrl&#39;, &#39;w&#39;,  &#39;leftContextSize&#39;,
               &#39;rightContextSize&#39;, &#39;N&#39;, &#39;O&#39;, &#39;O1&#39;, &#39;O2&#39;, &#39;E&#39;, &#39;pmi&#39;, &#39;mi2&#39;, &#39;mi3&#39;, &#39;logDice&#39;, &#39;ll&#39;`

        Details:
            The collocation analysis is currently implemented on the client side, as some of the functionality is not yet provided by the KorAP backend. Mainly for this reason it is very slow (several minutes, up to hours), but on the other hand very flexible. You can, for example, perform the analysis in arbitrary virtual corpora, use complex node queries, and look for expression-internal collocates using the focus function (see examples and demo).
            To increase speed at the cost of accuracy and possible false negatives, you can decrease searchHitsSampleLimit and/or topCollocatesLimit and/or set exactFrequencies to FALSE.
            Note that currently not the tokenization provided by the backend, i.e. the corpus itself, is used, but a tinkered one. This can also lead to false negatives and to frequencies that differ from corresponding ones acquired via the web user interface.

        Example:
            ```
            $ kcon = KorAPConnection(verbose=True)
            $ df = kcon.collocationAnalysis(&#34;Grund&#34;)
            ```
        &#34;&#34;&#34;
        return KorAPClient.collocationAnalysis(self, node, vc, **kwargs)

    def corpusQuery(self, *args, **kwargs):
        &#34;&#34;&#34;Query search term(s).

        - **query** - query string or list of query strings
        - **vc** - virtual corpus definition or list thereof (default: &#34;&#34;)
        - **KorAPUrl** - instead of specifying the `query` and `vc` string parameters, you can copy your KorAP query URL here from the browser
        - **metadataOnly** - determines whether queries should return only metadata without any snippets. This can also be useful to prevent access rewrites. (default = True)
        - **ql** - query language: `&#34;poliqarp&#34; | &#34;cosmas2&#34; | &#34;annis&#34; | &#34;cql&#34; | &#34;fcsql&#34;` (default = `&#34;poliqarp&#34;`)
        - **fields** - (meta)data fields that will be fetched for every match (default = `[&#34;corpusSigle&#34;, &#34;textSigle&#34;, &#34;pubDate&#34;,  &#34;pubPlace&#34;, &#34;availability&#34;, &#34;textClass&#34;]`)
        - **verbose** - (default = `self.verbose`)

        Returns:
            `KorAPQuery`

        Example:
            ```
            $ kcon = KorAPConnection(verbose=True)
            $ q = kcon.corpusQuery(&#34;Ameisenplage&#34;)
            $ q = q.fetchAll()
            $ q.slots[&#39;collectedMatches&#39;]
                corpusSigle  ...                                          textClass
            1         WPD17  ...                                                NaN
            2         WPD17  ...                                                NaN
            3         WPD17  ...                                                NaN
            4         WPD17  ...                                                NaN
            5         WPD17  ...                                                NaN
            ..          ...  ...                                                ...
            126         Z83  ...                       freizeit-unterhaltung reisen
            127       MZE03  ...  freizeit-unterhaltung reisen natur-umwelt wett...
            128       MZE03  ...  freizeit-unterhaltung reisen staat-gesellschaf...
            129       MZE14  ...  wissenschaft populaerwissenschaft freizeit-unt...
            130       MZE00  ...                  wissenschaft populaerwissenschaft
            [130 rows x 6 columns]
            ```
        &#34;&#34;&#34;
        return KorAPQuery(self, *args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>rpy2.robjects.methods.RS4</li>
<li>rpy2.robjects.robject.RObjectMixin</li>
<li>abc.ABC</li>
<li>rpy2.rinterface.SexpS4</li>
<li>rpy2.rinterface_lib.sexp.Sexp</li>
<li>rpy2.rinterface_lib._rinterface_capi.SupportsSEXP</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="KorAPClient.KorAPConnection.collocationAnalysis"><code class="name flex">
<span>def <span class="ident">collocationAnalysis</span></span>(<span>self, node, vc='', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>EXPERIMENTAL</strong>: Performs a collocation analysis for the given node (or query) in the given virtual corpus.</p>
<ul>
<li><strong>node</strong> - target word or list of target words</li>
<li><strong>vc</strong> - string or list of strings describing the virtual corpus in which the query should be performed. An empty string (default) means the whole corpus, as far as it is license-wise accessible.</li>
<li><strong>lemmatizeNodeQuery</strong> - if True, node query will be lemmatized, i.e. x -&gt; [tt/l=x]</li>
<li><strong>minOccur</strong> - minimum absolute number of observed co-occurrences to consider a collocate candidate</li>
<li><strong>leftContextSize</strong> - size of the left context window</li>
<li><strong>rightContextSize</strong> - size of the right context window</li>
<li><strong>topCollocatesLimit</strong> - limit analysis to the n most frequent collocates in the search hits sample</li>
<li><strong>searchHitsSampleLimit</strong> - limit the size of the search hits sample</li>
<li><strong>ignoreCollocateCase</strong> - bool, set to True if collocate case should be ignored</li>
<li><strong>withinSpan</strong> - KorAP span specification for collocations to be searched within</li>
<li><strong>exactFrequencies</strong> - if False, extrapolate observed co-occurrence frequencies from frequencies in search hits sample, otherwise retrieve exact co-occurrence frequencies</li>
<li><strong>stopwords</strong> - vector of stopwords not to be considered as collocates</li>
<li><strong>seed</strong> - seed for random page collecting order</li>
<li><strong>expand</strong> - if True, node and vc parameters are expanded to all of their combinations</li>
</ul>
<h2 id="returns">Returns</h2>
<p>DataFrame with columns <code>'node', 'collocate', 'label', 'vc','webUIRequestUrl', 'w',
'leftContextSize',
'rightContextSize', 'N', 'O', 'O1', 'O2', 'E', 'pmi', 'mi2', 'mi3', 'logDice', 'll'</code></p>
<h2 id="details">Details</h2>
<p>The collocation analysis is currently implemented on the client side, as some of the functionality is not yet provided by the KorAP backend. Mainly for this reason it is very slow (several minutes, up to hours), but on the other hand very flexible. You can, for example, perform the analysis in arbitrary virtual corpora, use complex node queries, and look for expression-internal collocates using the focus function (see examples and demo).
To increase speed at the cost of accuracy and possible false negatives, you can decrease searchHitsSampleLimit and/or topCollocatesLimit and/or set exactFrequencies to FALSE.
Note that currently not the tokenization provided by the backend, i.e. the corpus itself, is used, but a tinkered one. This can also lead to false negatives and to frequencies that differ from corresponding ones acquired via the web user interface.</p>
<h2 id="example">Example</h2>
<pre><code>$ kcon = KorAPConnection(verbose=True)
$ df = kcon.collocationAnalysis(&quot;Grund&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collocationAnalysis(self, node, vc=&#34;&#34;, **kwargs):
    &#34;&#34;&#34; **EXPERIMENTAL**: Performs a collocation analysis for the given node (or query) in the given virtual corpus.

    - **node** - target word or list of target words
    - **vc** - string or list of strings describing the virtual corpus in which the query should be performed. An empty string (default) means the whole corpus, as far as it is license-wise accessible.
    - **lemmatizeNodeQuery** - if True, node query will be lemmatized, i.e. x -&gt; [tt/l=x]
    - **minOccur** - minimum absolute number of observed co-occurrences to consider a collocate candidate
    - **leftContextSize** - size of the left context window
    - **rightContextSize** - size of the right context window
    - **topCollocatesLimit** - limit analysis to the n most frequent collocates in the search hits sample
    - **searchHitsSampleLimit** - limit the size of the search hits sample
    - **ignoreCollocateCase** - bool, set to True if collocate case should be ignored
    - **withinSpan** - KorAP span specification for collocations to be searched within
    - **exactFrequencies** - if False, extrapolate observed co-occurrence frequencies from frequencies in search hits sample, otherwise retrieve exact co-occurrence frequencies
    - **stopwords** - vector of stopwords not to be considered as collocates
    - **seed** - seed for random page collecting order
    - **expand** - if True, node and vc parameters are expanded to all of their combinations

    Returns:
        DataFrame with columns `&#39;node&#39;, &#39;collocate&#39;, &#39;label&#39;, &#39;vc&#39;,&#39;webUIRequestUrl&#39;, &#39;w&#39;,  &#39;leftContextSize&#39;,
           &#39;rightContextSize&#39;, &#39;N&#39;, &#39;O&#39;, &#39;O1&#39;, &#39;O2&#39;, &#39;E&#39;, &#39;pmi&#39;, &#39;mi2&#39;, &#39;mi3&#39;, &#39;logDice&#39;, &#39;ll&#39;`

    Details:
        The collocation analysis is currently implemented on the client side, as some of the functionality is not yet provided by the KorAP backend. Mainly for this reason it is very slow (several minutes, up to hours), but on the other hand very flexible. You can, for example, perform the analysis in arbitrary virtual corpora, use complex node queries, and look for expression-internal collocates using the focus function (see examples and demo).
        To increase speed at the cost of accuracy and possible false negatives, you can decrease searchHitsSampleLimit and/or topCollocatesLimit and/or set exactFrequencies to FALSE.
        Note that currently not the tokenization provided by the backend, i.e. the corpus itself, is used, but a tinkered one. This can also lead to false negatives and to frequencies that differ from corresponding ones acquired via the web user interface.

    Example:
        ```
        $ kcon = KorAPConnection(verbose=True)
        $ df = kcon.collocationAnalysis(&#34;Grund&#34;)
        ```
    &#34;&#34;&#34;
    return KorAPClient.collocationAnalysis(self, node, vc, **kwargs)</code></pre>
</details>
</dd>
<dt id="KorAPClient.KorAPConnection.collocationScoreQuery"><code class="name flex">
<span>def <span class="ident">collocationScoreQuery</span></span>(<span>self, node, collocate, vc='', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get collocation scores for given node(s) and collocate(s).</p>
<ul>
<li><strong>node</strong> - target word</li>
<li><strong>collocate</strong> - collocate of target word</li>
<li><strong>vc</strong> - virtual corpus definition or list thereof
(default: "")</li>
<li><strong>lemmatizeNodeQuery</strong> - logical, set to TRUE if node query should be lemmatized, i.e. x -&gt; [tt/l=x]</li>
<li><strong>lemmatizeCollocateQuery</strong> - logical, set to TRUE if collocate query should be lemmatized, i.e. x -&gt; [tt/l=x]</li>
<li><strong>leftContextSize</strong> - size of the left context window</li>
<li><strong>rightContextSize</strong> - size of the right context window</li>
<li><strong>scoreFunctions</strong> - named list of R (!) score functions of the form function(O1, O2, O, N, E, window_size), see e.g. KorAPClient.pmi</li>
<li><strong>smoothingConstant</strong> - smoothing constant will be added to all observed values</li>
</ul>
<h2 id="returns">Returns</h2>
<p>DataFrame with columns <code>'node', 'collocate', 'label', 'vc','webUIRequestUrl', 'w',
'leftContextSize',
'rightContextSize', 'N', 'O', 'O1', 'O2', 'E', 'pmi', 'mi2', 'mi3', 'logDice', 'll'</code></p>
<h2 id="example">Example</h2>
<pre><code>$ kcon = KorAPConnection(verbose=True)
$ df = kcon.collocationScoreQuery(&quot;Grund&quot;, &quot;triftiger&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collocationScoreQuery(self, node, collocate, vc=&#34;&#34;, **kwargs):
    &#34;&#34;&#34;Get collocation scores for given node(s) and collocate(s).

    - **node** - target word
    - **collocate** - collocate of target word
    - **vc** - virtual corpus definition or list thereof  (default: &#34;&#34;)
    - **lemmatizeNodeQuery** - logical, set to TRUE if node query should be lemmatized, i.e. x -&gt; [tt/l=x]
    - **lemmatizeCollocateQuery** - logical, set to TRUE if collocate query should be lemmatized, i.e. x -&gt; [tt/l=x]
    - **leftContextSize** - size of the left context window
    - **rightContextSize** - size of the right context window
    - **scoreFunctions** - named list of R (!) score functions of the form function(O1, O2, O, N, E, window_size), see e.g. KorAPClient.pmi
    - **smoothingConstant** - smoothing constant will be added to all observed values

    Returns:
        DataFrame with columns `&#39;node&#39;, &#39;collocate&#39;, &#39;label&#39;, &#39;vc&#39;,&#39;webUIRequestUrl&#39;, &#39;w&#39;,  &#39;leftContextSize&#39;,
           &#39;rightContextSize&#39;, &#39;N&#39;, &#39;O&#39;, &#39;O1&#39;, &#39;O2&#39;, &#39;E&#39;, &#39;pmi&#39;, &#39;mi2&#39;, &#39;mi3&#39;, &#39;logDice&#39;, &#39;ll&#39;`

    Example:
        ```
        $ kcon = KorAPConnection(verbose=True)
        $ df = kcon.collocationScoreQuery(&#34;Grund&#34;, &#34;triftiger&#34;)
        ```
    &#34;&#34;&#34;
    return KorAPClient.collocationScoreQuery(self, node, collocate, vc, **kwargs)</code></pre>
</details>
</dd>
<dt id="KorAPClient.KorAPConnection.corpusQuery"><code class="name flex">
<span>def <span class="ident">corpusQuery</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Query search term(s).</p>
<ul>
<li><strong>query</strong> - query string or list of query strings</li>
<li><strong>vc</strong> - virtual corpus definition or list thereof (default: "")</li>
<li><strong>KorAPUrl</strong> - instead of specifying the <code>query</code> and <code>vc</code> string parameters, you can copy your KorAP query URL here from the browser</li>
<li><strong>metadataOnly</strong> - determines whether queries should return only metadata without any snippets. This can also be useful to prevent access rewrites. (default = True)</li>
<li><strong>ql</strong> - query language: <code>"poliqarp" | "cosmas2" | "annis" | "cql" | "fcsql"</code> (default = <code>"poliqarp"</code>)</li>
<li><strong>fields</strong> - (meta)data fields that will be fetched for every match (default = <code>["corpusSigle", "textSigle", "pubDate",
"pubPlace", "availability", "textClass"]</code>)</li>
<li><strong>verbose</strong> - (default = <code>self.verbose</code>)</li>
</ul>
<h2 id="returns">Returns</h2>
<p><code><a title="KorAPClient.KorAPQuery" href="#KorAPClient.KorAPQuery">KorAPQuery</a></code></p>
<h2 id="example">Example</h2>
<pre><code>$ kcon = KorAPConnection(verbose=True)
$ q = kcon.corpusQuery(&quot;Ameisenplage&quot;)
$ q = q.fetchAll()
$ q.slots['collectedMatches']
    corpusSigle  ...                                          textClass
1         WPD17  ...                                                NaN
2         WPD17  ...                                                NaN
3         WPD17  ...                                                NaN
4         WPD17  ...                                                NaN
5         WPD17  ...                                                NaN
..          ...  ...                                                ...
126         Z83  ...                       freizeit-unterhaltung reisen
127       MZE03  ...  freizeit-unterhaltung reisen natur-umwelt wett...
128       MZE03  ...  freizeit-unterhaltung reisen staat-gesellschaf...
129       MZE14  ...  wissenschaft populaerwissenschaft freizeit-unt...
130       MZE00  ...                  wissenschaft populaerwissenschaft
[130 rows x 6 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corpusQuery(self, *args, **kwargs):
    &#34;&#34;&#34;Query search term(s).

    - **query** - query string or list of query strings
    - **vc** - virtual corpus definition or list thereof (default: &#34;&#34;)
    - **KorAPUrl** - instead of specifying the `query` and `vc` string parameters, you can copy your KorAP query URL here from the browser
    - **metadataOnly** - determines whether queries should return only metadata without any snippets. This can also be useful to prevent access rewrites. (default = True)
    - **ql** - query language: `&#34;poliqarp&#34; | &#34;cosmas2&#34; | &#34;annis&#34; | &#34;cql&#34; | &#34;fcsql&#34;` (default = `&#34;poliqarp&#34;`)
    - **fields** - (meta)data fields that will be fetched for every match (default = `[&#34;corpusSigle&#34;, &#34;textSigle&#34;, &#34;pubDate&#34;,  &#34;pubPlace&#34;, &#34;availability&#34;, &#34;textClass&#34;]`)
    - **verbose** - (default = `self.verbose`)

    Returns:
        `KorAPQuery`

    Example:
        ```
        $ kcon = KorAPConnection(verbose=True)
        $ q = kcon.corpusQuery(&#34;Ameisenplage&#34;)
        $ q = q.fetchAll()
        $ q.slots[&#39;collectedMatches&#39;]
            corpusSigle  ...                                          textClass
        1         WPD17  ...                                                NaN
        2         WPD17  ...                                                NaN
        3         WPD17  ...                                                NaN
        4         WPD17  ...                                                NaN
        5         WPD17  ...                                                NaN
        ..          ...  ...                                                ...
        126         Z83  ...                       freizeit-unterhaltung reisen
        127       MZE03  ...  freizeit-unterhaltung reisen natur-umwelt wett...
        128       MZE03  ...  freizeit-unterhaltung reisen staat-gesellschaf...
        129       MZE14  ...  wissenschaft populaerwissenschaft freizeit-unt...
        130       MZE00  ...                  wissenschaft populaerwissenschaft
        [130 rows x 6 columns]
        ```
    &#34;&#34;&#34;
    return KorAPQuery(self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="KorAPClient.KorAPConnection.corpusStats"><code class="name flex">
<span>def <span class="ident">corpusStats</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the size of the whole corpus or a virtual corpus specified by the vc argument.</p>
<ul>
<li><strong>vc</strong> (default = "")</li>
<li><strong>verbose</strong> (default = kco@verbose)</li>
<li><strong>as.df</strong> (default = True)</li>
</ul>
<h2 id="returns">Returns</h2>
<p><code>DataFrame</code>|<code>RS4</code></p>
<h2 id="example">Example</h2>
<pre><code>$ df = kcon.corpusStats(&quot;pubDate in 2018 &amp; textType=/Zeit.*/ &amp; pubPlaceKey=IT&quot;, **{&quot;as.df&quot;: True})
$ df[&quot;tokens&quot;]
12150897
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corpusStats(self, *args, **kwargs):
    &#34;&#34;&#34;Query the size of the whole corpus or a virtual corpus specified by the vc argument.

    - **vc** (default = &#34;&#34;)
    - **verbose** (default = kco@verbose)
    - **as.df** (default = True)

    Returns:
        `DataFrame`|`RS4`

    Example:
        ```
        $ df = kcon.corpusStats(&#34;pubDate in 2018 &amp; textType=/Zeit.*/ &amp; pubPlaceKey=IT&#34;, **{&#34;as.df&#34;: True})
        $ df[&#34;tokens&#34;]
        12150897
        ```
    &#34;&#34;&#34;
    default_kwargs = {&#34;as.df&#34;: True}
    default_kwargs.update(kwargs)
    return KorAPClient.corpusStats(self, *args, **default_kwargs)</code></pre>
</details>
</dd>
<dt id="KorAPClient.KorAPConnection.frequencyQuery"><code class="name flex">
<span>def <span class="ident">frequencyQuery</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Query relative frequency of search term(s).</p>
<ul>
<li><strong>query</strong> - query string or list of query strings</li>
<li><strong>vc</strong> - virtual corpus definition or list thereof
(default: "")</li>
<li><strong>conf.level</strong> - confidence level of the returned confidence interval (default = 0.95)</li>
<li><strong>as.alternatives</strong> - decides whether queries should be treated as mutually exclusive and exhaustive wrt. to some meaningful class (e.g. spelling variants of a certain word form) (default = False)</li>
<li><strong>KorAPUrl</strong> - instead of specifying the <code>query</code> and <code>vc</code> string parameters, you can copy your KorAP query URL here from the browser</li>
<li><strong>metadataOnly</strong> - determines whether queries should return only metadata without any snippets. This can also be useful to prevent access rewrites. (default = True)</li>
<li><strong>ql</strong> - query language: <code>"poliqarp" | "cosmas2" | "annis" | "cql" | "fcsql"</code> (default = <code>"poliqarp"</code>)</li>
<li><strong>accessRewriteFatal</strong> - abort if query or given vc had to be rewritten due to insufficient rights (not yet implemented) (default = <code>True</code>)</li>
<li><strong>verbose</strong> - (default = <code>self.verbose</code>)</li>
<li><strong>expand</strong> - bool that decides if <code>query</code> and <code>vc</code> parameters are expanded to all of their combinations (default = <code>len(vc) != len(query)</code>)</li>
</ul>
<h2 id="returns">Returns</h2>
<p>DataFrame with columns <code>'query', 'totalResults', 'vc', 'webUIRequestUrl', 'total', 'f',
'conf.low', 'conf.high'</code>.</p>
<h2 id="example">Example</h2>
<pre><code>$ kcon = KorAPConnection(verbose=True)
$ kcon.frequencyQuery(&quot;Ameisenplage&quot;, vc=[&quot;pubDate in &quot;+str(y) for y in range(2010,2015)])
                      query  totalResults  ...      conf.low     conf.high
1  Ameisenplage             3  ...  9.727696e-10  1.200289e-08
2  Ameisenplage            12  ...  3.838218e-09  1.275717e-08
3  Ameisenplage             5  ...  2.013352e-09  1.356500e-08
4  Ameisenplage             6  ...  2.691331e-09  1.519888e-08
5  Ameisenplage             3  ...  8.629463e-10  1.064780e-08
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frequencyQuery(self, *args, **kwargs):
    &#34;&#34;&#34;Query relative frequency of search term(s).

    - **query** - query string or list of query strings
    - **vc** - virtual corpus definition or list thereof  (default: &#34;&#34;)
    - **conf.level** - confidence level of the returned confidence interval (default = 0.95)
    - **as.alternatives** - decides whether queries should be treated as mutually exclusive and exhaustive wrt. to some meaningful class (e.g. spelling variants of a certain word form) (default = False)
    - **KorAPUrl** - instead of specifying the `query` and `vc` string parameters, you can copy your KorAP query URL here from the browser
    - **metadataOnly** - determines whether queries should return only metadata without any snippets. This can also be useful to prevent access rewrites. (default = True)
    - **ql** - query language: `&#34;poliqarp&#34; | &#34;cosmas2&#34; | &#34;annis&#34; | &#34;cql&#34; | &#34;fcsql&#34;` (default = `&#34;poliqarp&#34;`)
    - **accessRewriteFatal** - abort if query or given vc had to be rewritten due to insufficient rights (not yet implemented) (default = `True`)
    - **verbose** - (default = `self.verbose`)
    - **expand** - bool that decides if `query` and `vc` parameters are expanded to all of their combinations (default = `len(vc) != len(query)`)

    Returns:
        DataFrame with columns `&#39;query&#39;, &#39;totalResults&#39;, &#39;vc&#39;, &#39;webUIRequestUrl&#39;, &#39;total&#39;, &#39;f&#39;,
       &#39;conf.low&#39;, &#39;conf.high&#39;`.

    Example:
        ```
        $ kcon = KorAPConnection(verbose=True)
        $ kcon.frequencyQuery(&#34;Ameisenplage&#34;, vc=[&#34;pubDate in &#34;+str(y) for y in range(2010,2015)])
                              query  totalResults  ...      conf.low     conf.high
        1  Ameisenplage             3  ...  9.727696e-10  1.200289e-08
        2  Ameisenplage            12  ...  3.838218e-09  1.275717e-08
        3  Ameisenplage             5  ...  2.013352e-09  1.356500e-08
        4  Ameisenplage             6  ...  2.691331e-09  1.519888e-08
        5  Ameisenplage             3  ...  8.629463e-10  1.064780e-08
        ```
    &#34;&#34;&#34;
    return KorAPClient.frequencyQuery(self, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="KorAPClient.KorAPQuery"><code class="flex name class">
<span>class <span class="ident">KorAPQuery</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Query to a KorAP server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KorAPQuery(RS4):
    &#34;&#34;&#34;Query to a KorAP server.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        kco = KorAPClient.corpusQuery(*args, **kwargs)
        super().__init__(kco)

    def fetchNext(self, *args, **kwargs):
        &#34;&#34;&#34;Fetch next couple of query results

        - **offset** - start offset for query results to fetch
        - **maxFetch** - maximum number of query results to fetch
        - **verbose**
        - **randomizePageOrder** - fetch result pages in pseudo random order if true. (default = `False`)

        Returns:
            `KorAPQuery`
        &#34;&#34;&#34;
        return KorAPClient.fetchNext(self, *args, **kwargs)

    def fetchRest(self, *args, **kwargs):
        &#34;&#34;&#34;Fetch remaining query results

        - **verbose**

        Returns:
            `KorAPQuery`
        &#34;&#34;&#34;
        return KorAPClient.fetchRest(self, *args, **kwargs)

    def fetchAll(self, *args, **kwargs):
        &#34;&#34;&#34;Fetch all query results

        - **verbose**

        Returns:
            `KorAPQuery`

        Example:
            See `KorAPConnection.corpusQuery`.
        &#34;&#34;&#34;
        return KorAPClient.fetchAll(self, *args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>rpy2.robjects.methods.RS4</li>
<li>rpy2.robjects.robject.RObjectMixin</li>
<li>abc.ABC</li>
<li>rpy2.rinterface.SexpS4</li>
<li>rpy2.rinterface_lib.sexp.Sexp</li>
<li>rpy2.rinterface_lib._rinterface_capi.SupportsSEXP</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="KorAPClient.KorAPQuery.fetchAll"><code class="name flex">
<span>def <span class="ident">fetchAll</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch all query results</p>
<ul>
<li><strong>verbose</strong></li>
</ul>
<h2 id="returns">Returns</h2>
<p><code><a title="KorAPClient.KorAPQuery" href="#KorAPClient.KorAPQuery">KorAPQuery</a></code></p>
<h2 id="example">Example</h2>
<p>See <code><a title="KorAPClient.KorAPConnection.corpusQuery" href="#KorAPClient.KorAPConnection.corpusQuery">KorAPConnection.corpusQuery()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetchAll(self, *args, **kwargs):
    &#34;&#34;&#34;Fetch all query results

    - **verbose**

    Returns:
        `KorAPQuery`

    Example:
        See `KorAPConnection.corpusQuery`.
    &#34;&#34;&#34;
    return KorAPClient.fetchAll(self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="KorAPClient.KorAPQuery.fetchNext"><code class="name flex">
<span>def <span class="ident">fetchNext</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch next couple of query results</p>
<ul>
<li><strong>offset</strong> - start offset for query results to fetch</li>
<li><strong>maxFetch</strong> - maximum number of query results to fetch</li>
<li><strong>verbose</strong></li>
<li><strong>randomizePageOrder</strong> - fetch result pages in pseudo random order if true. (default = <code>False</code>)</li>
</ul>
<h2 id="returns">Returns</h2>
<p><code><a title="KorAPClient.KorAPQuery" href="#KorAPClient.KorAPQuery">KorAPQuery</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetchNext(self, *args, **kwargs):
    &#34;&#34;&#34;Fetch next couple of query results

    - **offset** - start offset for query results to fetch
    - **maxFetch** - maximum number of query results to fetch
    - **verbose**
    - **randomizePageOrder** - fetch result pages in pseudo random order if true. (default = `False`)

    Returns:
        `KorAPQuery`
    &#34;&#34;&#34;
    return KorAPClient.fetchNext(self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="KorAPClient.KorAPQuery.fetchRest"><code class="name flex">
<span>def <span class="ident">fetchRest</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch remaining query results</p>
<ul>
<li><strong>verbose</strong></li>
</ul>
<h2 id="returns">Returns</h2>
<p><code><a title="KorAPClient.KorAPQuery" href="#KorAPClient.KorAPQuery">KorAPQuery</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetchRest(self, *args, **kwargs):
    &#34;&#34;&#34;Fetch remaining query results

    - **verbose**

    Returns:
        `KorAPQuery`
    &#34;&#34;&#34;
    return KorAPClient.fetchRest(self, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="KorAPClient.expand_grid" href="#KorAPClient.expand_grid">expand_grid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="KorAPClient.KorAPConnection" href="#KorAPClient.KorAPConnection">KorAPConnection</a></code></h4>
<ul class="">
<li><code><a title="KorAPClient.KorAPConnection.collocationAnalysis" href="#KorAPClient.KorAPConnection.collocationAnalysis">collocationAnalysis</a></code></li>
<li><code><a title="KorAPClient.KorAPConnection.collocationScoreQuery" href="#KorAPClient.KorAPConnection.collocationScoreQuery">collocationScoreQuery</a></code></li>
<li><code><a title="KorAPClient.KorAPConnection.corpusQuery" href="#KorAPClient.KorAPConnection.corpusQuery">corpusQuery</a></code></li>
<li><code><a title="KorAPClient.KorAPConnection.corpusStats" href="#KorAPClient.KorAPConnection.corpusStats">corpusStats</a></code></li>
<li><code><a title="KorAPClient.KorAPConnection.frequencyQuery" href="#KorAPClient.KorAPConnection.frequencyQuery">frequencyQuery</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="KorAPClient.KorAPQuery" href="#KorAPClient.KorAPQuery">KorAPQuery</a></code></h4>
<ul class="">
<li><code><a title="KorAPClient.KorAPQuery.fetchAll" href="#KorAPClient.KorAPQuery.fetchAll">fetchAll</a></code></li>
<li><code><a title="KorAPClient.KorAPQuery.fetchNext" href="#KorAPClient.KorAPQuery.fetchNext">fetchNext</a></code></li>
<li><code><a title="KorAPClient.KorAPQuery.fetchRest" href="#KorAPClient.KorAPQuery.fetchRest">fetchRest</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>